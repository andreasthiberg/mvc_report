{# templates/report.html.twig #}
{% extends 'base.html.twig' %}

{% block title %}Redovisning{% endblock %}
{% block content %}
    <h1>Redovisningssida</h1>
    <h2>Kmom01</h2>
    <h3>Berätta kort om dina förkunskaper och tidigare erfarenheter kring objektorientering.</h3>
    Jag har erfarenhet av objektorienterad programmering från tidigare kurser, då med Javascript och Python. Jag har alltså en ganska bra känsla för grunderna i hur klasser och objekt skrivs och används. De skillnader som jag har märkt hittills i PHP verkar mest handla om syntax.

    <h3>Berätta kort om PHPs modell för klasser och objekt. Vilka är de grunder man behöver veta/förstå för att kunna komma igång och skapa sina första klasser?</h3>
    En klass skapas och ges i namn. I klassen definierar man sedan ett antal medlemsvariabler (oftast som privata, så att de bara kan användas direkt inom klassen), och metoder. Valfritt är att definiera en konstruktor som tar emot argument och direkt sätter medlemsvariablers värden. Även en destruktor är valfri, men behövs sällan.
    Man skapar sedan nya instanser (objekt) av klassen genom syntaxet syntaxet new (klassnamn). Man kan komma åt metoder och publika variabler i ett objekt genom pilnotation. 

    <h3>Reflektera kort över den kodbas, koden, strukturen som användes till uppgiften me/report, hur uppfattar du den?</h3>
    Just nu är det lite många delar i Symfony för att ha riktig koll på allt, men vi har ju använt MVC-strukturen tidigare, så den gick ganska lätt att komma igång med den och att lägga till sin egen controller och sina egna templates. Det tog ett tag att förstå hur man skulle skapa separata templates för headers och footers, men sen gick det bra.
    Just nu har jag bara lagt till grundläggande CSS, men tanken är att repetera lite SASS framöver.
    
    <h3>Med tanke på artikeln “PHP The Right Way”, vilka delar in den finner du extra intressanta och värdefulla?</h3>
    Ett område som vi inte har gått igenom mycket särskilt mycket tidigare är säkerhet, hashing, osv. Så det ska bli kul att lära sig mer om. Namespaces verkar vara ett användbart koncept som jag ser fram emot att lära mig att använda. Avslutningsvis så ska det bli kul att titta närmare på hur php används med databaser, efter den senaste databas-kursen.

    <h3>Vilken är din TIL för detta kmom?</h3>
    Autoloading är ett nytt koncept för mig! Att importera klasser till höger och vänster är ju alltid lite struligt, så det verkar smidigt.
    <br>    <br>
    <h2>Kmom02</h2>
<h3>Förklara kort de objektorienterade konstruktionerna arv, komposition, interface och trait och hur de används i PHP.</h3>
Komposition innebär att en klass innehåller en eller flera andra klasser. I den här uppgiften gäller det exempelvis klassen CardHand, som kan innehålla ett antal object av klassen Card. Ett antal Card-objekt är i det här fallet alltså knutna till ett specifikt CardHand-objekt. Komposition är användbart för att på det här sättet knyta samman olika objekt som representerar olika "enheter" i ett program.
<br><br>
Arv används för att konstruera en ny klass med utgångspunkt i en existerande klass. Den nya klassen tar beståndsdelarna i den gamla klassen och lägger sedan till nya, alternativt justerar några av de gamla. Det är användbart för att skapa en "special-variant" av en mer allmän klass. I PHP görs detta genom att klassen definieras med ett "extends"-kommando. Man kan komma åt metoder från basklassen med prefixet "parent::".
<br><br>
Interface är en slags "ritning" för en klass, det vill säga en förteckning över vilka metoder klassen ska innehålla. För att se till att en klass följer ett interface används konstruktionen "implements <interface>" när klassen definieras. Ett interface blir en garanti för att en klass går att använda på särskilda sätt, även om man gör ändringar i klassen (som måste hålla sig inom ramarna för ett interface).
<br><br>
Ett trait är som ett stycke kod som stoppas in i en ny klass. Genom att stoppa sin kod i en trait - snarare än direkt i en klass - så kan samma trait återanvändas av flera olika klasser. Dessutom kan en enskild klass använda sig av många olika traits - i php går det nämligen inte att ärva från flera klasser, så man använder traits istället. Här användes konstruktionen "use" för att importera ett trait till en klass.


<h3>Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden och dina klasser?</h3>
Jag är ganska nöjd med min implementation, även om det tog ett tag att få allt på plats. Det känns som att klasserna är lagom komplicerade och som att det finns ett bra samband emellan dem. En funderingen är att CardHand-klassen kanske inte behövs, i och med att varje spelare bara kan ha en "Hand" - men uppdelningen som jag har nu kan ju eventuellt bli användbar framöver om kortspel ska implementeras.

Jag är lite osäker på om jag har löst hanteringen av POST/GET-routes på bästa sätt: Som det ser ut nu så används speciella handler-routes för att ta emot POST-requests från formulär, för att dra ett antal kort osv. Men det fungerar i alla fall.

<h3>Vilken är din TIL för detta kmom?</h3>
Hur man jobbar med relativa länkar till specifika route-namn i twig-filer. Och hur man arbetar med POST/GET i en PHP-miljö som symfony!
    <br><br>
<h2>Kmom03</h2>
<h3>Berätta hur det kändes att modellera ett kortspel med flödesdiagram och psuedokod. Var det något som du tror stödjer dig i din problemlösning och tankearbete för att strukturera koden kring en applikation?</h3>
Kortspelet var ju i det här fallet ganska simpelt, så jag tror att jag hade klarat mig ganska bra utan flödesdiagram och liknande. Med det sagt så tycker jag att det har en intressant funktion att arbeta med planering innan man börjar med själva kodningen: Min vanliga process är att helt enkelt börja skriva kod och sen pröva mig fram och lägga till nya delar som behövs. Det brukar ju fungera i slutändan, men resultatet kan ofta bli lite rörligt. Jag misstänker att om man arbetar mer med planering så kan man komma över "prövo-stadiet" tidigare vilket resulterar i ett mer strukturerat slutresultat.


<h3>Berätta om din implementation från uppgiften. Hur löste du uppgiften, är du nöjd/missnöjd, vilken förbättringspotential ser du i din koden, dina klasser och applikationen som helhet?</h3>
Jag är nöjd! Det kändes bra att det var så enkelt att använda sig av de klasser jag skrev i förra momentet, och att spelet därför gick enkelt att implementera. Eventuellt hade man kunnat lösa själva interaktionen med användaren på ett att sätt - nu användare jag mig av formulär och POST-routes rakt av, men jag är inte säker på att det är det mest naturliga sättet - det blir ju lite märkligt med ett spel där sidan laddas om varje gång användaren gör något.

<h3>Vilken är din känsla för att koda i ett ramverk som Symfony, så här långt in i kursen?</h3>
Det känns ganska bra. Det känns lite rörigt med alla olika delar, men i stort så liknar ju Symfony andra ramverk som vi/jag har använt, så jag har en känsla för hur de olika elementen hänger ihop. MVC-systemet med templates och controllers är ju lite mer komplicerade än de SPA-sidor som vi har gjort i andra kursen, men jag gissar att det också har större potential inom olika användningsområden. Spontant så känns det svårare att jobba med interaktiva element i Symfony än i exempelvis React, men det kanske bara kräver lite mer kunskap. 

<h3>Vilken är din TIL för detta kmom?</h3>
Hur man arbetar med stark typning i PHP på olika sätt. Det krävdes en del mixtrande för att ta phpstan skulle vara nöjd.

    <br><br>
<h2>Kmom04</h2>
<h3>Berätta hur du upplevde att skriva kod som testar annan kod med PHPUnit och hur du upplever phpunit rent allmänt.</h3>

Jag tyckte att det gick ganska lätt att skriva tester - jag har gjort det i andra språk vid tidigare tillfällen så jag är bekant med utformningen och processen. PHPUnit tinnebar egentligen inga särskilda utmaningar utan det gick snabbt och smidigt att skriva tester. Det var också enkelt att skriva (de visserligen enkla) mock-klasserna som jag behövde för att testa några delar av koden.

<h3>Hur väl lyckades du med kodtäckningen av din kod, lyckades du nå mer än 90% kodtäckning?</h3>
Vad jag kan se så har jag 100% på alla klasser. Jag löste det genom att helt enkelt ta itu med de rader som inte var testade en efter en. Det enda som var lite lurigt var att testa kortspelets reaktion på olika poäng - jag var tvungen att läsa mock-versioner av kort för det, och göra lite små ändringar i klassen.

<h3>Upplever du din egen kod som “testbar kod” eller finns det delar i koden som är mer eller mindre testbar och finns det saker som kan göras för att förbättra kodens testbarhet?</h3>
Jag tyckte det gick ganska lätt att testa koden i allmänheten, eftersom all funktionalitet är tydligt uppdelad i olika klasser och metoder. Det enda jag känner mig osäker på är det faktum att många av klasserna är beroende av andra klasserna - klassen Player innehåller objekt av klassen CardHand, som innehållet objekt av klassen Card, osv. Det gör att ändringar i klassen Card kan få alla tester att sluta fungera. Man kan säkert komma runt detta med mer komplicerade mocks - men jag visste inte riktigt hur jag skulle förhålla mig till det här.

<h3>Valde du att skriva om delar av din kod för att förbättra den eller göra den mer testbar, om så berätta lite hur du tänkte.</h3>
Jag gjorde bara små ändringar för att tillåta testerna att skicka in mockade spelkort i klassen Game. Det verkade nödvändigt för att kunna testa hur spelet reagerar på specifika kort - innan skedde dragningen av kort enbart automatiskt inne i klassen.

<h3>Fundera över om du anser att testbar kod är något som kan identifiera “snygg och ren kod”.</h3>
De saker som verkar göra koden testbar - modulering, att den är tydligt uppdelad i olika funktioner där varje funktion har en särskild roll - är ju saker som också kännetecknar snygg kod.  I övrigt så förenklar tydligt skriven kod (t.ex. namn på metoder) avsevärt när man ska skriva specifika tester för olika funktioner.

<h3>Vilken är din TIL för detta kmom?</h3>
Hur man skriver mocks - jag tror att detta var första gången jag prövade på det, även om jag har skrivit enhetstester i andra språk tidigare.

<h2>Kmom05</h2>
<h3>Gick det bra att jobba igenom övningen med Symfony och Doctrine. Något särskilt du tänkte/reagerade på under övningen?</h3>
Det gick bra! Allting installerades lätt och smidigt. Det blev först lite problem när jag råkade skapa felaktiga migrations och inte förstod hur man blev av med dem, men det löste sig så småningom. Nu när jag har fått ett hum om hur ORM fungerar så känns det spontat som en lättnad i jämförelse med all den SQL som vi skrev i exempelvis databas-kursen! Men jag antar att både har sina användningsområden.

<h3>Berätta om din applikation och hur du tänkte när du byggde upp den. Tänkte du något speciellt på användargränssnittet? Gick det bra att jobba med ORM i CRUD eller vad anser du om det?</h3>
Gränssnittet är inte så vackert med det gör jobbet. Det viktigaste i det här fallet var ju tydlig interaktion med CRUD och tydlig presentation av resultatet. Jag tycket inte att det var några större svårigheter att jobba med CRUD - det kändes som en naturlig förlängning av de POST-routes som jag skrev i det förra momentet. Jag är nog inte helt hundra än på hur det fungerar med entities, repositories osv, men det verkar ganska intuitivt (och som sagt mer lätthanterligt än ren SQL).

<h3>Berätta om du gjorde (delar av) extrauppgiften med användare och login.<h3>
Det gjorde jag inte! I nuläget vill jag helst komma vidare till slutprojektet. Jag jobbar dock gärna med detta där om möjlighet ges och om jag har tid.

<h3>Vad är din uppfattning om ORM så här långt och relatera gärna till andra sätt att jobba med applikationskod mot databaser?</h3>
Jag upprepar det jag skrev ovan - ORM är lite av en lättnad i jämförelse med SQL-kod. Jag förstår nyttan med det senare, men trots mycket övande i databas-kursen så kändes allting fortfarande ganska snårigt, och som ett lite obekvämt avbrott med den mer smidigt objektorienterad programmering som används i andra sammanhang. Så det var ju trevligt att även databas-interaktion kan överföras till den "sidan" på det här sättet.

<h3>Vilken är din TIL för detta kmom?</h3>
Kanske snarare "TIRemembered" - men efter att ha jobbat med MongoDB och MariaDB i några kurser så hade jag glömt hur smidigt det är med SQLIite för lite mindre projekt.

<h2>Kmom06</h2>
<h3>Hur uppfattade du verktyget phpmetrics och fann du några särskilda bitar mer värdefulla än andra? Var det några särskilda metrics eller bilder du uppskattade?</h3>
Verktyget var lite förvirrande i början, men när jag fick grepp om det så verkade det användbart.
I mitt fall var det mest användbart för att analysera de olika klassernas komplexitet - presentationen av "storleken" för varje klass var onekligen tydlig. Något jag inte riktigt begriper är hur varje klass "Maintainability index" räknas ut - jag trodde att det skulle minska när jag fick ned komplexiteten, men så blev det inte. Jag får återkomma till det i projektet. 

<h3>Berätta hur det gick att integrera med Scrutinizer och vilken är din första känsla av verktyget och dess badges? Vilken kodtäckning och kodkvalitet fick du efter första bygget?</h3>
Det gick bra, även om det strulade lite i början - jag var tvungen att manuellt ange en vissa PHP-version i config-filen för att analysen inte skulle krascha. När det väl fungerade så gick det dock smidigt. Egentligen fanns det dock inte jättemycket att hämta i just det här fallet - jag fick 10 poäng direkt, och den låga Coverage-siffran berodde bara på att jag inte hade för avsikt att testa mina Controllers och ORM-klasser. Hur som helst så kändes det nyttigt att lära sig, och det blir säkert användbart för kommande utveckling.

<h3>Hur är din egen syn på kodkvalitet, berätta lite om den? Tror du man kan man påvisa kodkvalitet i någon viss mån med badges eller vad tror du?</h3>
På ett sätt känns kodkvalitet ganska tydligt - ett gäng olika mätvärden räknas ihop och så får man ett betyg. Jag tror att den typen av "trubbig" analys räcker ganska långt i många fall: Målet är ju oftast inte att skriva perfekt kod, utan snarare att åtgärda stora brister i hur ett program är uppbyggt. I det avseendet fungerar också badges som någon sorts kvalitetsgaranti. Å andra sidan så tror jag inte att man ska stirra sig blind på betyg/badges. Mina testfall tydliggjorde att ett alltför nitiskt följande av mätvärden snarare kan göra koden mindre intuitiv och läsbar. Det finns säkert också många typer av system som analysverktygen inte riktigt kan tolka ordentligt. Men de fungerar onekligen bra som en utgångspunkt när man vill skriva bra kod.

<h3>Vilken är din TIL för detta kmom?</h3>
Av de fyra C:na så tyckte jag särskilt Coupling kändes nytt och intressant. Även om man skriver modulärt (som vi har lärt oss) så blir det ju lätt långa kedjor av klasser som är beroende av varandra, och som därför blir känsliga för förändringar. Jag hade velat tittat närmare på hur man ska förhålla sig till sådana problem.


{% endblock %}